\documentclass[a4paper,11pt]{article}
\usepackage[margin=3cm]{geometry}

\title{Report for Final Project IP Autumn 2026}
\date{Deadline: 29th Jan.  23:59}

\author{Alex, Komari, Natalia, and Penelope}

\begin{document}

\maketitle

\section*{Task Description}

The project involves developing an interpreter to manage a small programming language that allows for mutation a simple integer array. The programming language includes operations (memory allocation and deallocation, arithmetic/logical operations, and printing) which need to be recognized and executed, while returning runtime errors as specified. The program disposes of limited memory space (100 cells) which needs to be managed efficiently. Finally, the program needs to be subdivided into different modules built on top of each other; each module should be able to treat the functions of the module below as black box. This allows for independent development and testing of each module. 


\section*{Structure of the Project}
Each module was created based on a clear task breakdown:
\begin{itemize}
    \item main.c: Read the input file given by user and process line by line. Reports runtime errors.
    \item interpreter.c: Parse and interpret each line (3-character command, parameter1 and parameter2) and select operations.
    \item memory.c: manages the memory required by the mini-language. It provides functions to allocate and free contiguous memory blocks as well as to read and modify certain cells in memory.
    \item functions.c: Program operations required for the programming language as well as variable tracking.

\end{itemize}

To make use of the modularity of Abstract Data Types (ADTs), each module was accompanied by a header file that reveals only the necessary functionalities.

\section*{Data Structures and Implementation Choices}

\begin{itemize}
	\item \textbf{Memory}: the data structures used are a fixed-size array of 100 integer cells and a linked list to track free memory. Each node of the list stores the start position and length of a contiguous free block in memory. This design was chosen because to avoid scanning the entire memory array on each (de) allocation. Allocation uses a \emph{best-fit} strategy, selecting smallest free blocks that can satisfy requests. This reduces fragmentation while keeping implementation simple. In the worst case, allocation runs in $O(n)$ where $n$ is the number of free segments. Deallocation reinserts a freed block into the free list in order and deals with overlapping/adjacent segments. To ensure safety, the module prevents access to unallocated memory, checking the free list, which also runs in $O(n)$. The module owns and manages its internal memory state entirely as the internal \texttt{Memory} struct is not exposed in header file, enforcing encapsulation.
    \item Variables: ///
\end{itemize}

\section*{Testing}

Explain how you tested your code.Here you should explain and justify the testing strategies that you used. Do not just say "I used the tester program". 

\section*{Self-Reflection}

Explain what you learned during this project



\end{document}
